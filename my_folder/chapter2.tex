\chapter{Алгоритмы составления расписания сессии} \label{ch2}
	
% не рекомендуется использовать отдельную section <<введение>> после лета 2020 года
%\section{Введение} \label{ch2:intro}

Глава посвещена обзору алгоритмов, которые можно применять для составления расписания сессии, а также для оптимизации этого процесса. 

В параграфе \ref{ch2:sec1} приведена постановка задачи составления расписания сессии, далее в параграфе \ref{ch2:sec2} рассморены два возможных режима составления расписания, а в параграфе \ref{ch2:sec3} - алгоритмы, используемые для решения данной задачи.

\section{Постановка задачи составления расписания сессии} \label{ch2:sec1} 

Для составления расписания учебной сессии в университете необходимо каждой запланированной аттестации подобрать день, время и аудиторию проведения. 
Известны доступные аудитории и множество аттестаций, которые необходимо провести в рамках сессии. Для каждой аудитории известно время ее доступности. Для каждого типа аттестации определена длительность, максимальное количество в день и количество дней отдыха до и после её проведения. Нужно составить расписание сессии так, чтобы общая эффективность расписания была наибольшей.

\subsection{Обозначения} 

Составим расписание сесии для g учебных групп, каждая из которых характеризуется номером и количеством учащихся в ней студентов. 

Множество номеров учебных групп: 
\begin{align}
	& Gr\ =  \{ gr_1,..,gr_g \} 
\end{align}

Количество студентов в соответсвующей учебной группе: 
\begin{align}
	& S\ =  \{ s_1,..,s_g \} 
\end{align}

В данной задаче необходимо учитывать пожелания преподавателей, поэтому каждый преподаватель помимо ФИО должен характеризоваться множеством удобных для него дней и часов проведения аттестаций. Также преподавателям необходимо прописывать приоритет, чтобы в случаях, когда нельзя удовлетворить пожеланиям всех преподавателей, в первую очередь будут учитываться пожеланиям именно преподавателей с большим приоритетом.

Множество, состоящее из p имён преподавателей ВУЗа:
\begin{align}
	& T\ =  \{t_1,..,t_p \} 
\end{align}

Приоритеты соответсвующих преподавателей:
\begin{align}
	& Pr\ =  \{pr_1,..,pr_p \} 
\end{align}

Множество из q дней, которые преподаватель t выбрал возможными для проведения им аттестаций:
\begin{align}
& Td_t\ =  \{td_{t1},..,td_{tq} \} 
\end{align}

Множество из c часов, которые преподаватель t выбрал возможными для проведения им аттестаций:
\begin{align}
& Tt_t\ =  \{tt_{t1},..,tt_{tc} \} 
\end{align}

Важно также учитывать правила проведения сессий, ограничивающие количество аттестаций в день и определяющие, сколько дней отдыха нужно оставить группе до и после аттестации.

Определим множество из y типов аттестаций (экзамен, зачёт и т.п.):
\begin{align}
	& A\ =  \{a_1,..,a_y\} 
\end{align}

Количество дней отдыха перед (Pb)  и после (Pa) проведением аттестации каждого типа:
\begin{align}
	& Pb =  \{pb_1,..,pb_y\}\\ 
	& Pa =  \{pa_1,..,pa_y\} 
\end{align}

Длительность каждого типа аттестации в часах:
\begin{align}
	& Ad =  \{ad_1,..,ad_y\}
\end{align}

Максимальное количество аттестаций каждого типа в день:
\begin{align}
	& Ac =  \{ac_1,..,ac_y\} 
\end{align}

При выборе аудиторий для проведения аттестаций необходимо полагаться на их размер и техническую оснащённость. Опрелелим множество из u номеров аудиторий:
\begin{align}
	& R =  \{r_1,..,r_u\} 
\end{align}

Типы соответсвующих аудиторий (компьютерный класс, имеет проектор и т.п.):
\begin{align}
	& Rt =  \{rt_1,..,rt_y\} 
\end{align}

Количество мест в соответсвующих аудиториях:
\begin{align}
	& Rs =  \{rs_1,..,rs_y\} 
\end{align}

Аттестации, которые необходимо провести в течение сессии описываются учбной группой, дисциплиной и преподавателями, которые должны провести данную аттестацию. Так же для каждой аттестации необходимо указать её тип и тип аудитории, в которой она должна проводиться.

Множество аттестаций:
\begin{align}
	& {E} =  \{ e_1,..,e_k\}
\end{align}

Множества групп (Еg) и дисциплин (Ec) для каждой из k аттестаций:
\begin{align}
	& Eg =  \{ eg_i\in{}Gr , \forall  i \in{} \{1,..,k\} \} \\ 
	& {Ec} =  \{ ec_1,..,ec_k\}
\end{align}

Множества типов аттестаций и типов аудиторий для каждой из k аттестаций:
\begin{align}
	& Ea =  \{ ea_i\in{}A , \forall  i \in{} \{1,..,k\} \} \\ 
	& Er =  \{ er_1,..,er_k\}
\end{align}

Множество, состоящее из преподавателей, проводящих аттестацию e:
\begin{align}
	& Et_e =  \{ et_{ei}\in{}T , \forall  i \}
\end{align}

Каждой аттестации необходимо сопоставить дату, часы и аудиторию для проведения. Декартово произведение всех возможных дат, часов и свободных кабинетов представляет собой множество потенциальных окон для проведения аттестаций.

Множество окон:
\begin{align}
	& W =  \{w_1,..,w_n\} 
\end{align}

${wd_i \in D}$ - календарный день, соответствующий окну i;

${wh_i \in H}$ - время, соответствующее окну i;

${wc_i\in{}R , \forall  i \in{} \{1,..,n\}}$ - аудитория, соответствующая окну i.


Введём множество Solutions, состоящее из функций булевых переменных, которые принимают значение 1, если за i-ей аттестацией бронируется j-е окно:
\begin{equation}
	S(i,j) = 
	\begin{cases}
		1 &\text{ the attestation $e_i$ is held in window $w_j$} \\
		0 &\text{ the attestation $e_i$ is not held in window $w_j$}
	\end{cases}
\end{equation}

Таким образом, необходимо найти значения функции ${S \in Solutions}$ для ${ \forall  i  \in \{1,..,k\}}$  и  ${ \forall j \in \{1,..,n\}}$. Множество пар <i,j>, для которых S(i,j) = 1, представляют собой расписание сессии - соотвествие аттестации дню, врмени и аудитории.

\subsection{Ограничения}
Задача составления расписания сессии имеет ряд физических ограничений, а также ограничений, обусловленных правилами проведения сессии. Соблюдение этих ограничений позволит составить корректное расписание сессии:

Во-первых, в одной аудитории в одно время может проводиться только одна аттестация:
\begin{align}
	& \forall  j \in \{1,..,n\} \sum_{i=1}^kS(i,j) = 1
\end{align}

Каждая аттестация в период сессии должна проводиться единожды, так как в данном случае не рассматривается расписание дополнительной сессии:
\begin{align}
	& \forall  i \in \{1,..,k\} \sum_{j=1}^nS(i,j) = Ad_ea_i
\end{align}

Преподаватель не должен отрабатывать в определённый день больше некоторого количества часов x:
\begin{align}
	& \forall b \in \{1,..,p\} : \sum_{\forall i \in \{1,..,k\}, et_{ia}=t_b}\sum_{\forall j \in \{1,..,n\}}\sum_{ \forall u \in d_u \in D, wd_j = d_u }S(i,j) <= x
\end{align}

Любая группа не может сдавать аттестации любого типа в день больше, чем макисмальное число, обусловленное типом аттестации:
\begin{align}
\begin{multlined}
	 \forall b \in \{1,..,g\}, \forall j \in \{1,..,n\}, \forall m \in \{1,..,y\} :\\ \sum_{\forall i \in \{1,..,k\}, et_i = a_m,  eg_i=gr_b}\sum_{ \forall d \in D, wd_j = d }S(i,j) <= ac_m * ad_m
\end{multlined}
\end{align}

Любая группа перед любой своей аттестацией не должна иметь аттестаций в окно отдыха перед аттестацией этого типа:
\begin{align}
	\begin{multlined}
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\
		 \max_{\forall j \in \{1,..,n\}, ed_j < ed_i}(ed_j) <ed_i-pb_{et_i}
	\end{multlined}
\end{align}

Любая группа после любой своей аттестацией не должна иметь аттестаций в окно отдыха после аттестацией этого типа:
\begin{align}
	\begin{multlined}
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\
		\min{\forall j \in \{1,..,n\}, ed_j > ed_i}(ed_j) >ed_i-pa_{et_i}
	\end{multlined}
\end{align}

Каждая аттестация должна проводиться в аудитории равной и или превосходящей по вместимости размеру группы:
\begin{align}
	& \forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : s_{eg_i} > rs_{wc_j} \rightarrow S(i,j) = 0
\end{align}

Каждая аттестация не может проводиться в аудитории с оснащённостью меньшей ожидаемой:
\begin{align}
	& \forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : er_i < rt_{wc_j} \rightarrow S(i,j) = 0
\end{align}

Чтобы составить расписание, комфортное для преподавательского состава, учтём некоторые ограничения связанные с предпочтениями преподавателей. Эти огнаричения уже не столь критичны, как перечисленные выше, так как их нарушение не влечёт за собой нарушение правил или законов физики, но их наличие делает расписание более удобным для сотрудников.

Каждый преподаватель волен указать список календарных дней, в которые он готов принимать аттестации. Идеальное расписание предполагает, что любой преподаватель проводит все свои аттестации только в дни из этого списка:
\begin{align}
	\label{eq:T1}
	& \forall t \in T, \forall d \in D : d \notin Td_t \rightarrow S(i,j) = 0
\end{align}

Также, преподаватель может указать удобные для него часы провеления аттестаций. Идеальное расписнаие учитывает это и располагает аттестации так, чтобы они затрагивали только выбранные часы каждого преподавателя:
\begin{align}
	\label{eq:T2}
	& \forall t \in T, \forall h \in H : h \notin Tt_h \rightarrow S(i,j) = 0
\end{align}

Данная задача относится к классу NP-полных задач, а значит в худшем исходе придётся перебрать все возможные k аттестаций и n окон в качестве аргументов функции S(i,j), где выполняются все описанные выше ограничения. Обобщим их для функции S:

\begin{equation}
	\label{eq:S}
	S(i,j) = 
	\begin{cases}
		\forall  j \in \{1,..,n\} \sum_{i=1}^kS(i,j) = 1;\\
		\forall  i \in \{1,..,k\} \sum_{j=1}^nS(i,j) = Ad_ea_i;\\
		\forall b \in \{1,..,p\} : \\ \sum_{\forall i \in \{1,..,k\}, et_{ia}=t_b}\sum_{\forall j \in \{1,..,n\}}\sum_{ \forall u \in d_u \in D, wd_j = d_u }S(i,j) <= x;\\
		\forall b \in \{1,..,g\}, \forall j \in \{1,..,n\}, \forall m \in \{1,..,y\} :
		\\ \sum_{\forall i \in \{1,..,k\}, et_i = a_m,  eg_i=gr_b}\sum_{ \forall d \in D, wd_j = d }S(i,j) <= ac_m * ad_m;\\
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b: \\ \max\limits_{\forall j \in \{1,..,n\}, ed_j < ed_i}(ed_j) <ed_i-pb_{et_i};\\
	\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\ \min\limits_{\forall j \in \{1,..,n\}, ed_j > ed_i}(ed_j) >ed_i-pa_{et_i};\\
	\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : s_{eg_i} > rs_{wc_j} \rightarrow S(i,j) = 0;\\
	\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : er_i < rt_{wc_j} \rightarrow S(i,j) = 0\\
	\end{cases}
\end{equation}

Оптимальным расписанием будет такое, где минимальное количество пожеланий преподавателей игнорируется. Таким образом, сведём задачу к поиску такого расписания S, на котором выполняется слудеющий минимум:

\begin{align}
	\label{eq:T}
	& \min_{\forall S \in Solutions}(\sum_{\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\}, wd_j \notin Td_{et_i}, wh_j \notin Th_{et_i}}(S(i,j)*pr_{et_i}))
\end{align}

Видно, что идеальными расписаниями будут те, где учитываются пожелания всех преподавателей, так как в этом случае точно достигается наименьшее значение минимума формулы \eqref{eq:T} = 0. 

 Для решения данной задачи рассмотрим алгоритмы динамического и линейного программирования, алгоритм на графах, эволюционный алгоритм и метод численной оптимизации.

\section{Режимы алгоритмов составления расписния} \label{ch2:sec2} 

Алгоритмы составления расписания можно использовать в двух режимах: инкрементальном и пакетном (batch-режим). В данном разделе рассмотрим, что из себя представляет каждый из этих режимов и почему пакетный режим больше подходит для решения задачи составления расписания сессии.

\subsection{Инкрементальный режим}

Инкрементальным режимом назовём выполнение алгоритма многократно при появлении новых данных. В контексте данной задачи это означает, что каждый раз, когда новый преподаватель будет добавлять информацию о своих предпочтениях, алгоритм будет просчитывать возможные варианты расписания с учётом:
\begin{itemize}
	\item уже имеющихся данных, которые имеют приоритет, перед новыми;
	\item внесённых преподавателем изменений.
\end{itemize}

Так, при каждом новом пересчёте уже составленные расписания преподавателей считаются утверждёнными, что даёт возможность не считать их заново, тем самым ускорив работу алгоритма.

Из преимуществ данного подхода можно выделить возможность преподавателя, не дожидаясь других, увидеть своё расписание. Также, с точки зрения организации, плюсом можно считать стимул преподавателей как можно раньше заполнить форму сбора информации, чтобы иметь приоритет перед другими. Таким образом появляется возможность раньше закончить процесс составление расписания. 

Недостатки данного режима более существенны на практике, чем его преимущества, так как основным недостатком является закрепление наиболее удобного расписания за теми, кто заполнил форму сбора раньше остальных, что может повлечь коллизии. Можно рассмотреть случай, когда первый преподаватель, заполнивший форму сбора, выбирает большое окно для проведения экзаменов и алгоритм бронирует за ним несколько определённых случайных дат, а остальные оставляет свободными. Тогда второй преподаватель, уезжающий на конференцию в свободные даты и готовый провести экзамены в даты, занятые первым, уже не сможет это сделать, потому что у первого преподавателя приоритет, и его уже нельзя подвинуть на сводные даты.

\subsection{Пакетный режим}

Пакетным режимом в данном случае будет единоразовая обработка всех полученных сведений. Для этого необходимо определить дедлайн для сбора пожеланий преподаватель, при наступлении которого составить предварительное расписание для всех за один вызов алгоритма. 

Преимуществом такого подхода является возможность установить приоритеты преподавателей и групп, на основе которых можно решать коллизии в случае невозможности нахождения идеального решения, учитывающего пожелания каждого. 

Недостатком такого подхода можно назвать невозможность до дедлайна получить расписание, но в реальности это не будет глобальным минусом, потому что составленное таким образом предварительное расписание, всё равно, в последствии может быть скорректировано вручную. 

Таким образом, из двух рассмотренных режимов для решения задачи составления расписания больше подходит именно пакетный, потому что его преимущества более значимы, а единственный недостаток не играет роли на практике, в отличие от описанных недостатков инкремениального режима.

\section{Обзор алгоритмов составления расписания сессии} \label{ch2:sec3} 
\subsection{Обход графа в глубину для поиска идеальных решений}

Как упоминалось ранее, задача составления расписания сессии является NP-полной. Задача обхода графа тоже NP-полна, и существует множество классических алгоритмов, решающих её. Алгоритм обхода графа в глубину является одним из них. Но чтобы применить этот алгоритм для составления расписания, необходимо свести эту задачу к задаче построения графа, у которого в качестве вершин выступают элементы расписания - аттестации и временные окна для их проведния. Наличие ребра обуславливается выполнением двух следующих условий:
\begin{itemize}
	\item ребро из вершины с аттестацией i из отсортрованного списка аттестаций E, может быть соединено только с аттестацией i+1 из E;
	\item ребро из вершины <i,j> с аттестацией i и окном j в вершину <i+1, q> может существовать, если выполняются условия формул \eqref{eq:S}, \eqref{eq:T1} и \eqref{eq:T2} для S(i+1, q) при n=i+1.
\end{itemize}

 Тогда решением будет являться связный граф состоящий из k вершин - пар аттестаций и временных окон, отведённых для этих аттестаций.

Основная идея обхода в глубину – когда возможные пути по ребрам, выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим веткам. Сложность классического обхода в глубину с матричным заданием графа равна ${O(m^2)}$, где {$m=n*k$} - количество вершин. Но так как известно, что доступность рёбер для каждой из вершин с аттестацией i огрничена n вершинами с аттестацией i+1, сложность снизится до ${O(n^2 * k)}$. Но так как для проверки остальных условий необходимо проверять i предыдущих вершин графа, сложность останется ${O(n^2 * k*\log(k))}$.

 В процессе решения занчениями функции S(i,j) будет заполняться булева матрица. Важно помнить, что значение 1 в ячейке может быть проставлено, только при соблюдении ограничений системы \eqref{eq:S} , и стоит заметить, что выполнение ограничения, что в одной аудитории в одно время может проводиться только одна аттестация, влечёт за собой наличие в одном столбце матрицы не более одного значения 1, из-за чего матрицу можно заменить на целочисленный массив, где индексы соответствуют индексу возможного окна, а значения - индексу события, которое будет там проведено.

Будем считать, что идеальное решение найдено, если в каждой строке матрицы есть значение 1 или каждое число от 0 до k встречается в массиве решения, что означает, что каждую аттестацию можно сопоставить какому-то окну ${w_j}$ c учётом перечисленных выше ограничений. Такое решение добавляется в список всех идеальных решений. Даллее представлен псевдокод процедуры FindSolutions \ref{alg:algoFindSol}. , которая реализует алгоритм обхода графа в глубину. Заметим, что в списке доступных окон W все элементы отсортированы по дням, кабинетам и часам, чтобы легко можно было оценивать занятость одного кабинета несколько часов подряд.

	\begin{algorithm} 
	\SetKwFunction{algoFindSol}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSol}{
		\KwInput{$\cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[Solutions]$} 
		{$Solutions \leftarrow \{\}, $}
		{$S \leftarrow [], $}
			{$i \leftarrow 0$}\\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$ Solutions$}
				} \Else {
					{$i \leftarrow i-1$}\\
				}
			} \Else {
		   		{$duration = ed_i $}\\
		   		\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
		   			{$S[b] \leftarrow i$}\\
		   		}
				{$i \leftarrow i+1$}\\
			}
			\If{$i = k$ }{
					{$Solutions \leftarrow S$}\\
					{$i \leftarrow i-1$}\\
			} 
		}
	\Return {$ Solutions$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} для составления расписания}\label{alg:algoFindSol}
\end{algorithm} 

В процедуре FindNextStartTime \ref{alg:algoFindNextPr} проводится проверка условий из формулы \eqref{eq:S}, чтобы подобрать следующее подходящее ребро, исходящее из указанной вершины. В случае, если для вершины не существует исходящего ребра, которое удовлетворяет всем условиям, данная процедура вернёт значение -1, в противном случае вернёт следующее ребро. В данной функции также происходит проверка условий из формул \eqref{eq:T1} и \eqref{eq:T2}, чтобы обеспечить поиск идеального решения, удовлетворяющего пожланиям всех преподавателей. 

\begin{algorithm} 
\SetKwFunction{algoFindNext}{} 
	\SetKwProg{myalg}{Function}{ FindNextStartTime}{}
	\nonl\myalg{\algoFindNext}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$t$} 
		\If{$ time < 0$ } {
			\Return -1 \\
		}	
		\For{$i \in \{time,...,k\} $}{
			{$w \leftarrow W[i]$}\\
			\If {$S[i] = -1 
				\land rt_{w} = er_{event}  
				\land i + ad_{event} < n 
				\land s_{eg_{event}} <= er_{w}
				\land er_{w} = er_{W[i+ad_{event}]}
				\land ed_{w} = ed_{W[i+ad_{event}]}
				\land wd \in Td_{event}
				\land wt \in Tt_{event}
				\land wt+ed_{w} \in Tt_{event}$}
			{
				{$teacherTime \leftarrow 0, countPerDay \leftarrow 0, 	j \leftarrow 0 $} \\
		\While{$i < k$}{
			\If {$S[j] = -1 $}{
				{$j \leftarrow j+1$}\\
				{$continue$}\\
			}
			\If {$w = S[j] 	\land wt \in et_{solution[j]}$}{
				{$break$}\\
			}
			\If {$et_{S[j]} = et_{event}$}{
			{$teacherTime=teacherTime+1$}\\
			\If {$teacherTime > maxTimePerDay - ed_{event}$}{
				{$break$}\\
			}
		}
		\If {$eg_{S[j]} = eg_{event}$}{
			\If {$(ea_{S[j]=ea_{event}}) \land (wd = ed_{S[j]})$}{
				{$ countPerDay \leftarrow countPerDay+1 $} \\
				\If {$(ac_{et_{event}} < countPerDay) \lor (wt-pb_{ea_{event}}<=wd_{S[j]}\land wt+pa_{ea_{event}}>=wd_{S[j]})$}{
						{$break$}\\
					}
		}
			{$k \leftarrow k+1$}
		}	
	}
	\If{$j = n$}{
		 \Return {$i$} \\
	}
			}
		}
	\Return -1
	}
\caption{Проверка условий формул \eqref{eq:S}, \eqref{eq:T1} и \eqref{eq:T2}}\label{alg:algoFindNext}
\end{algorithm} 

\subsection{Алгоритм обхода графа в глубину с учётом приоритетов преподавателей}

На практике возникают ситуации, когда недостаток аудиторий и накладки в личных расписаниях преподавателей не позволяют найти такое расписание, которое удовлетворит всем пожеланиям. По этой причине приходится учитывать приоритеты ограничений и минимизировать потери по формуле \eqref{eq:T}. 

Существует ряд ограничений, поступиться с которыми нельзя. В их число входят правила проведения аттестаций и физические условия, связанные с проведением экзаменов в аудиториях, опписанные в формуле \eqref{eq:S}. Но есть и менее жёсткие факторы - это пожелания преподавателей к датам и времени экзаменов. 

Каждый преподаватель указывает дни и время, когда ему было бы удобно присутствовать на аттестации. В некоторых случаях удобство эквивалентно тому, что в остальные дни преподаватель в принципе не может принимать экзамены. Приоритет таких ограничений должен быть выше, чем у случаев, когда преподавателю просто комфортнее было бы присутствовать на экзаменах в определённые дни.

Для этого было введено множество приоритетов Pr, где больший приоритет соответствует большему влиянию учёта пожеланий преподавателя на потери функции \eqref{eq:T}. Система приоритетов в случае появления коллизий при составлении расписания позволит в первую очередь пытаться нарушить только пожелания с наименьшим приоритетом и только, если это необходимо, с более высокими.

Модернизируем алгоритм поиска «идеального» решения:

Для этого нужно хранить массив ignoreWishes, в котором будут фиксироваться те аттестации, для которых приходится искать решения без учёта предпочтений преподавателей.

Также, в алгоритме \ref{alg:algoFindSolPr} на строке \ref{step:sortE} необходимо отсортировать массив аттестаций по приоритетам преподавателей, чтобы искать решения без учёта высокоприоритетных преподавателей лишь в последнюю очередь. 

Метод поиска решений FindSolutions \ref{alg:algoFindSolPr} теперь содержит условный оператор, который в случае определения того, что идеального решения найти не удаётся, переходит в режим игнорирования пожеланий преподавателя для конкретного события. Для этого в массиве ignoreWishes выставляется true по индексу, соотвествующему этому событию.

\begin{algorithm} 
	\SetKwFunction{algoFindSolPr}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSolPr}{
		\KwInput{$\cont[P], \cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[S]$} 
		{$ignoreWishes \leftarrow [], $}
		{$S \leftarrow [], $}
		{$i \leftarrow 0$}\\
		{$Sort(E)$\label{step:sortE}} \\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If {$ ignoreWishes[i] = False \land nextTime = -1$ }{
				{$ignoreWishes[i] = True$} \\
				{$nextTime = FindNextStartTime(i,0)$}\\
			}
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$null$}
				} \Else {
				{$ignoreWishes[i] = False$}\\
					{$i \leftarrow i-1$}\\
				}
			} \Else {
				{$duration = ed_i $}\\
				\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
					{$S[b] \leftarrow i$}\\
				}
				{$i \leftarrow i+1$}\\
			}
		}
		\Return {$ S$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} для составления расписания c учётм приоритетов преподавателей}\label{alg:algoFindSolPr}
\end{algorithm} 

Метод поиска следующего подходящего времени и аудитории теперь может работать в двух режимах. В режими игнорирования рассматриваются только те окна, которые хотя бы в какой-то мере не удовлетворяют пожеланиям преподавателя. Для этого в алгоритме \ref{alg:algoFindNextPr} в строке \ref{step:ignor} используется логический оператор XOR между результатом проверки соблюдения пожеланий преподавателя и значением в массиве игнорирования.

\begin{algorithm} 
	\SetKwFunction{algoFindNextPr}{} 
	\SetKwProg{myalg}{Function}{ FindNextStartTime}{}
	\nonl\myalg{\algoFindNextPr}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]|, ignoreWishes $} 
		\KwOutput{$t$} 
		\If{$ time < 0$ } {
			\Return -1 \\
		}	
		\For{$i \in \{time,...,k\} $}{
			{$w \leftarrow W[i]$}\\
			{$teacherWish \leftarrow (wd \in Td_{event}
				\land wt \in Tt_{event}
				\land wt+ed_{w} \in Tt_{event}) \nsim ignoreWishes[i]$ \label{step:ignor}}\\
			\If {$S[i] = -1 
				\land rt_{w} = er_{event}  
				\land i + ad_{event} < n 
				\land s_{eg_{event}} <= er_{w}
				\land er_{w} = er_{W[i+ad_{event}]}
				\land ed_{w} = ed_{W[i+ad_{event}]}
				\land teacherWish$}
			{
			...\\
				}
				\If{$j = n$}{
					\Return {$i$} \\
				}
			}
		\Return -1
	}
	\caption{Проверка условий формулы \eqref{eq:S} с учётом режима игнорирования}\label{alg:algoFindNextPr}
\end{algorithm} 

Асимптотическая сложность этой интерпретации алгоритма тоже равна ${O(n^2 * k)}$, но требует дополнительную память на хранение бинарного массива ignoreWishes. 

\section{Методы оптимизации поиска лучших решений} \label{ch2:sec4} 
\subsection{Метрики оценки качества расписания}
Для оценки предложенных расписаний подсчитаем несколько метрик:

Длительность сессии для каждого преподавателя с учётом его приоритета:
\begin{align}
	& {DurationT} =  \sum\limits_{\forall  t \in T}(pr_t* (\max\limits_{i \in \{0,...,n\}, et_{S[i]} = t}(wd_{i}) 
	- \min\limits_{i \in \{0,...,n\}, et_{S[i]} = t}(wd_{i}) )) 
\end{align}

Считаем, что расписание преподавателя должно быть максимально компактным по датам, а значит разницу между первым и последним днём проведения экзаменов нужно минимизировать.

Суммарная длительность минимального отдыха между экзаменами по группам:
\begin{align}
	& {Pause} =  \sum\limits_{\forall  gr \in Gr}(\min\limits_{i,j \in \{0,...,n\}, eg_{S[i]} = gr, wd_i \neq wd_j, i>j}(wd_i - wd_j))
\end{align}
Считаем, что студентам желательно не иметь маленьких перерывов между экзаменами, поэтому стремимся максимизировать Pause для расписания.

Суммарная длительность сессии по группам:
\begin{align}
	& {DurationG} =  \sum\limits_{\forall  gr \in Gr}\max\limits_{i \in \{0,...,n\}, eg_{S[i]} = gr}(wd_ij)
\end{align}

Чем раньше закончится сессия, тем раньше у иногородних студентов появится возможность уехать домой, а значит порядковый номер последнего дня сессии для группы нужно пытаться минимизировать.

Суммарное кол-во рабочих дней для преподавателей с учётом их приоритетов:
\begin{align}
	& Work_t = \{wd_i, \forall i \ in {1,...,n}, et_{S[i]} = t\};\\
	& {WDays} =  \sum\limits_{\forall  t \in T}(pr_t * \|Work_t\|) 
\end{align}

Считаем, что преподавателю удобно иметь максимальное количество дней, свободных от проведения экзаменов, а значит метрику WDays стараемся минимизировать. На практике это означает, что лучше провести несколько зачётов в один день, чем заставлять человека несколько раз в неделю приезжать в университет.

Метод getRates(int[] sol) позволит рассчитать все описанные выше метрики для конкретного расписания и вернёт их в качестве одномерного массива длины 4.


\subsection{Метод ветвей и границ}
Метод ветвей и границ принадлежит к группе алгоритмов целочисленного линейного программирования и применяется для оптимизации задач полного перебора. Он как нельзя кстати придётся для модернизации алгоритма полного обхода графа в глубину.
Суть этого метода состоит в том, чтобы в процессе обхода графа, отбрасывать заведомо менее оптимальные решения, чем у же найденные.

Такой подход потребует выделить память под хранение метрик качества. В памяти необходимо держать качество текущего расчитываемого расписания и предыдущего лучшего расписания.
В качестве метрики качества возьмём разброс между первым и последним днём проведения сессии для каждого преподавателя. Чем он меньше, тем лучше считается расписание. Естественно, можно выбрать и другие критерии качества расписания, но алгоритм при этом поменяется незначительно.
Выбор такой метрики вынуждает хранить массив с количеством дней разброса для каждого преподавателя, поэтому выделим память под масиивы metrics[] и bestMetrics[] размером p (число преподавателей).

Модернизируем функцию поиска решений методом обхода графа в глубину, 
добавив в качестве условия перехода к следующей аттестации проверку на то, является ли расписание на данном этапе, худшим, чем предыдущее полностью составленное расписание. Эта проверка добавляется в строке \ref{step:isitw} алгоритма \ref{alg:algoFindSolV}.

	\begin{algorithm} 
	\SetKwFunction{algoFindSolV}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSolV}{
		\KwInput{$\cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[Solutions]$} 
		{$metrics \leftarrow [], $}
		{$bestMetrics \leftarrow [], $}
		{$Solutions \leftarrow \{\}, $}
		{$S \leftarrow [], $}
		{$i \leftarrow 0$}\\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$ Solutions$}
				} \Else {
					{$i \leftarrow i-1$}\\
				}
			} \Else {
				{$duration = ed_i $}\\
				\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
					{$S[b] \leftarrow i$}\\
				}
				{$i \leftarrow i+1$}\\
				 \If {$i = 0 \lor \urcorner isItWorse(i)$ \label{step:isitw}} {
					{$i \leftarrow i+1$}\\
				} \Else {
				\Return {$ Solutions $}\\
			}
		}
			\If{$i = k$ }{
				{$Solutions \leftarrow S$}\\
				{$bestMetrics \leftarrow metrics$}\\
				{$i \leftarrow i-1$}\\
			} 
		}
		\Return {$ Solutions$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} c использованием метода ветвей и границ} \label{alg:algoFindSolV}
\end{algorithm} 
	
Функция isItWorse \ref{alg:algoW} пересчитывает для рассматриваемого преподавателя длительность его сессии и проверяет, не является ли оно худшим, чем у того же преподавателя в предыдущем полном расписании. Для этого в массиве текущего решения находится максимальный и минимальный день, для рассматриваемого преподавателя и возвращается их разница.

\begin{algorithm} 
	\SetKwFunction{algoW}{} 
	\SetKwProg{myalg}{Function}{ isItWorse}{}
	\nonl\myalg{\algoW}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]|, ignoreWishes $} 
		\KwOutput{$t$} 
		{$max,min \leftarrow wd_{n-1}, i \leftarrow event - 1$}\\
		\While{$ i >= 0 \land et_{i} = et_{event}$ } {
	{$ j \leftarrow \min_{j \in {0,k-1}, S[j]=i}(j)  $}\\
	\If{$ wd_j > max$}{
		{$max = wd_j$}\\
	} \ElseIf{$wd_j < min$}{
		{$min = wd_j$}
	}
	{$ i \leftarrow i - 1$}\\
}
{$ metrics[event] \leftarrow max-min$}\\
\Return {$ bestMetrics[0] \neq -1 \land bestMetrics[et_{event}] < metrics[et_{event}]$}
	}
	\caption{Функция сравнения метрики качества для преподавателя с предыдущим лучшим решением}	
	\label{alg:algoW}
\end{algorithm} 


\subsection{Алгоритм иммитации отжига}
Для выбора лучшего из расписаний и расчёта всех метрик необходимо будет дополнительно обойти x расписаний, состоящих из n возможных временных окон. А потом просуммировать их по p преподавателям и z учебным группам. 
Если входные данные были такими, что было найдено 5-10 возможных расписаний, то не составит труда просчитать их все, так как относительно n (временные окна по аудиториям), оно вносит минимальный вклад в сложность вычислений.

Но рассмотрим случай, когда методом полного перебора было найдено большое количество возможных расписаний, и число x достаточно велико и даже сравнимо с n. В такой ситуации было бы полезно находить более оптимальные решения без расчёта метрик для каждого расписания, жертвуя некоторой погрешностью.

Для этого можно применить оптимизационный алгоритм имитации отжига. Он основан на имитации физического процесса отжига металлов - при постепенно понижающейся температуре переход атома из одной ячейки кристаллической решётки в другую происходит с некоторой вероятностью, которая понижается с понижением температуры.

При помощи моделирования такого процесса ищется такая точка или множество точек, на котором достигается минимум некоторой числовой функции F(x), где x принадлежит множеству возможных решений. 

Для задачи выбора лучшего расписания функция F(x) - функция, вычисляющая качество расписания, например, по метрике S (суммарная продолжительность сессии для каждой группы) из раздела Метрики выбора лучшего решения, которая рассчитывается в методе getRate(int i), где i - индекс расписания в массиве решений.

