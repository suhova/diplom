\chapter{Реализация алгоритма поиска расписаний с учётом приоритетов преподавателей на Java}\label{appendix-source}	

\begin{lstlisting}
import java.util.*;
	
	public class SchedulePriorAlgorithm {
		List<Event> events;
		List<DateTimeClass> dtc;
		int[] solution;
		int eventSize;
		int dtcSize;
		int maxTimePerDay;
		boolean[] ignoreWishes; //приходится ли игнорировать пожелания преподавателя для этого события
		
		public SchedulePriorAlgorithm(List<Event> events, List<DateTimeClass> dtc, int maxTimePerDay) {
			this.events = events;
			// отсортируем события так, чтобы аттестации, котороые проводятся более приоритетным преподавателями, были раньше
			Collections.sort(this.events);
			this.dtc = dtc;
			this.eventSize = events.size();
			this.dtcSize = dtc.size();
			this.maxTimePerDay = maxTimePerDay;
			
			this.solution = new int[dtcSize];
			for (int i = 0; i < dtcSize; i++) {
				solution[i] = -1;
			}
			this.ignoreWishes = new boolean[eventSize];
		}
		
		boolean findSolution() {
			int event = 0;
			while (event < eventSize) {
				int time = this.getTime(event);
				int nextTime;
				this.cleanEvent(event);
				nextTime = this.findNextStartTime(event, time);
				
				//переходим в режим игнорирования пожеланий преподавателя, если не смогли найти идеального решения
				if(!ignoreWishes[event] && nextTime == -1){
					ignoreWishes[event] = true;
					nextTime = this.findNextStartTime(event, 0);
				}
				
				if (nextTime == -1) { //если не удалось найти другого подходящего DateTimeClass для этого события
					if (event == 0) {
						return false; //если речь о первом событии, то уже были перебраны все остальные варинты, и решения нет
					} else {
						ignoreWishes[event] = false;
						event--; // иначе возвращаемся к предыдущему событию и пробуем изменить для него DateTimeClass
					}
				} else {
					this.submitDateTimeClass(event, nextTime); //бронируем за событием время и аудиторию
					event++; // переходим к следующему событию
				}
			}
			return true;
		}
		
		private int findNextStartTime(int event, int time) {
			if (time < 0) return -1;
			
			int duration = events.get(event).type.duration;
			for (int i = time; i < dtcSize; i++) {
				DateTimeClass location = dtc.get(i);
				Event ev = events.get(event);
				Group group = ev.group;
				Set<Teacher> teachers = ev.teacher;
				boolean success = false;
				
				boolean teacherWishes = teachers.stream().mapToInt(teacher -> {
					if (teacher.date.stream().anyMatch(dt -> dt.equals(location.date))
					&& teacher.time.stream().anyMatch(t -> t == location.time)
					&& teacher.time.stream().anyMatch(t -> t == location.time + duration)) return 0;
					else return 1;
				}).sum() == 0;
				if (ignoreWishes[event]) {
					teacherWishes = !teacherWishes;
				}
				if (solution[i] == -1 // аудитория в это время свободна
				&& ev.wishedClassroomType <= location.classroom.type //есть ли в аудитории нужное оборудование
				&& group.size <= location.classroom.size //влезает ли группа в аудиторию
				// не слишком ли сейчас поздно для начала проведения длительного события
				&& i + duration < dtcSize
				&& location.classroom.num == dtc.get(i + duration).classroom.num
				&& location.date.equals(dtc.get(i + duration).date)
				// подходит ли дата и время преподавателю
				&& teacherWishes
				) {
					Map<String, Integer> teacherTime = new HashMap<>();
					int countPerDay = 0;
					for (int k = 0; k < dtcSize; k++) {
						// если время-место свободны, они не повлияют на ограничения
						if (solution[k] == -1) continue;
						
						Event currentEvent = events.get(solution[k]);
						DateTimeClass currentLocation = dtc.get(k);
						
						// если проверяемая аудитория в это время занята
						if (location.date.compareTo(currentLocation.date) == 0) {
							break;
						}
						// если у преподавателя в этот день уже были занятия
						if (currentLocation.date == location.date) {
							for (Teacher curT : currentEvent.teacher) {
								for (Teacher teacher : teachers) {
									if (curT.name.equals(teacher.name)) {
										if (teacherTime.containsKey(teacher.name)) {
											teacherTime.put(teacher.name, 1);
										} else {
											teacherTime.compute(teacher.name, (key, v) -> v + 1);
										}
										// если преподаватель уже достаточно отработал в этот день.
										if (teacherTime.get(teacher.name) > maxTimePerDay - duration) {
											break;
										}
									}
								}
							}
						}
						if (currentEvent.group.group.equals(group.group)) {
							//если в этот день уже были занятия у этой группы
							if (currentEvent.type.type.equals(ev.type.type) && location.date == currentLocation.date) {
								countPerDay++;
								if (ev.type.countPerDay < countPerDay) {
									break;
								}
							}
							//если до или после события есть другое событие, до которого меньше "отдыха", чем нужно
							if (location.date.minusDays(ev.type.pauseBefore).compareTo(currentLocation.date) <= 0
							&& location.date.plusDays(ev.type.pauseAfter).compareTo(currentLocation.date) >= 0) {
								break;
							}
							
						}
						if (k == dtcSize - 1) success = true;
					}
				}
				if (success) return i;
			}
			return -1;
		}
		
		private void cleanEvent(int event) {
			for (int i = 0; i < dtcSize; i++) {
				if (solution[i] == event) solution[i] = -1;
			}
		}
		
		// бронинирование за событием помещения и времени
		private void submitDateTimeClass(int event, int nextTime) {
			int duration = events.get(event).type.duration;
			for (int i = nextTime; i < nextTime + duration; i++) {
				solution[i] = event;
			}
		}
		
		// возвращает следующий свободный индекс DateTimeClass для указанного события
		private int getTime(int event) {
			int min = -1;
			boolean contains = false;
			for (int i = 0; i < dtcSize - 1; i++) {
				// если аудитория в это время ещё никем не забронирована
				if (solution[i] == -1) {
					if (contains) {
						return i;
					} else if (min == -1) {
						min = i;
					}
				}
				// если это событие уже бронировало какое-то время и место
				if (solution[i] == event) {
					if (contains) return i;
					contains = true;
				}
			}
			// если последняя ячейка была занята текущим событием, то следующей для него нет
			if (contains) return -1;
			return min;
		}
	}
\end{lstlisting}