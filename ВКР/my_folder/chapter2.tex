\chapter{Алгоритмы составления расписания сессии} \label{ch2}
Глава посвящена обзору алгоритмов, которые можно применять для составления расписания сессии, а также для оптимизации этого процесса. 

В параграфе~\ref{ch2:sec1} приведена математическая постановка задачи составления расписания сессии, далее в параграфе~\ref{ch2:sec2} рассмотрены два возможных режима составления расписания, а в параграфах~\ref{ch2:sec3} и~\ref{ch2:sec4} - алгоритмы, используемые для решения данной задачи. 

\section{Постановка задачи составления расписания сессии} \label{ch2:sec1} 

Для составления расписания учебной сессии в университете необходимо каждой запланированной аттестации, запланированной у преподавателя, подобрать день, время и аудиторию проведения. 
Известны доступные аудитории и множество аттестаций, которые необходимо провести в рамках сессии. Для каждой аудитории известно время ее доступности. Для каждого типа аттестации определена длительность, максимальное количество в день и количество дней отдыха до и после её проведения. Нужно составить расписание сессии так, чтобы оно соответствовало некоторым критериям качества.
Далее введём математические обозначения для названных выше параметров, формализуем ограничения и определим, какое расписание будет являться оптимальным.

%\textbf{ПА: В РАБОТЕ ИСПОЛЬЗУЕТСЯ ДОВОЛЬНО много обозначений и скорее всего они где-то заимствованы, поэтому нужно расставить ссылки.} 
%Обозначения - СЛУЧАЙНЫЕ буквы латинского алфавита и операции над множествами. Ссылку оставлять не на что.

\subsection{Обозначения} 

Составим расписание сессии для каждой из $\overline{1,g}$ учебных групп, которые характеризуются номером и количеством учащихся в ней студентов. 

Множество номеров учебных групп: 
\begin{align}
	& Gr\ =  \{ gr_1,...,gr_g \}.
\end{align}

Количество студентов в соответствующей учебной группе: 
\begin{align}
	& S\ =  \{ s_1,...,s_g \}.
\end{align}

В данной задаче необходимо учитывать пожелания преподавателей, поэтому каждый преподаватель, помимо ФИО, должен характеризоваться множеством удобных для него дней и часов проведения аттестаций. Также преподавателям необходимо прописывать приоритет, чтобы в случаях, когда нельзя удовлетворить пожеланиям всех преподавателей, в первую очередь будут учитываться пожеланиям именно преподавателей с большим приоритетом.

Множество, состоящее из p имён преподавателей ВУЗа:
\begin{align}
	& T\ =  \{t_1,...,t_p \}.
\end{align}

Приоритеты соответствующих преподавателей:
\begin{align}
	& Pr\ =  \{pr_1,..,pr_p \}. 
\end{align}

Множество из q дней, которые преподаватель t выбрал возможными для проведения им аттестаций:
\begin{align}
	& Td_t\ =  \{td_{t1},...,td_{tq} \}. 
\end{align}

Множество из c часов, которые преподаватель t выбрал возможными для проведения им аттестаций:
\begin{align}
	& Tt_t\ =  \{tt_{t1},...,tt_{tc} \}. 
\end{align}

Важно также учитывать правила проведения сессий, ограничивающие количество аттестаций в день и определяющие, сколько дней отдыха нужно оставить группе до и после аттестации.

Определим множество из y типов аттестаций (экзамен, зачёт и т.п.):
\begin{align}
	& A\ =  \{a_1,...,a_y\}. 
\end{align}

Количество дней отдыха перед (Pb)  и после (Pa) проведением аттестации каждого типа:
\begin{align}
	& Pb =  \{pb_1,...,pb_y\}\\ 
	& Pa =  \{pa_1,...,pa_y\}. 
\end{align}

Длительность каждого типа аттестации в часах:
\begin{align}
	& Ad =  \{ad_1,...,ad_y\}.
\end{align}

Максимальное количество аттестаций каждого типа в день:
\begin{align}
	& Ac =  \{ac_1,...,ac_y\}.
\end{align}

При выборе аудиторий для проведения аттестаций необходимо полагаться на их размер и техническую оснащённость. Определим множество из u номеров аудиторий:
\begin{align}
	& R =  \{r_1,...,r_u\}.
\end{align}

Типы соответствующих аудиторий (компьютерный класс, имеет проектор и т.п.):
\begin{align}
	& Rt =  \{rt_1,...,rt_y\}.
\end{align}

Количество мест в соответствующих аудиториях:
\begin{align}
	& Rs =  \{rs_1,..,rs_y\} .
\end{align}

Аттестации, которые необходимо провести в течение сессии описываются учебной группой, дисциплиной и преподавателями, которые должны провести данную аттестацию. Так же для каждой аттестации необходимо указать её тип и тип аудитории, в которой она должна проводиться.

Множество аттестаций:
\begin{align}
	& {E} =  \{ e_1,...,e_k\}.
\end{align}

Множества групп (Еg) и дисциплин (Ec) для каждой из k аттестаций:
\begin{align}
	& Eg =  \{ eg_i\in{}Gr , \forall  i \in{} \{1,..,k\} \} \\ 
	& {Ec} =  \{ ec_1,...,ec_k\}.
\end{align}

Множества типов аттестаций и типов аудиторий для каждой из k аттестаций:
\begin{align}
	& Ea =  \{ ea_i\in{}A , \forall  i \in{} \{1,..,k\} \} \\ 
	& Er =  \{ er_1,...,er_k\}.
\end{align}

Множество, состоящее из преподавателей, проводящих аттестацию e:
\begin{align}
	& Et_e =  \{ et_{ei}\in{}T , \forall  i \}.
\end{align}

Каждой аттестации необходимо сопоставить дату, часы и аудиторию для проведения. Декартово произведение всех возможных дат, часов и свободных кабинетов представляет собой множество потенциальных окон для проведения аттестаций.

Множество окон:
\begin{align}
	& W =  \{w_1,..,w_n\}, 
\end{align}

для которых ${wd_i \in D}$ - календарный день, соответствующий окну i, ${wh_i \in H}$ - время, соответствующее окну i, ${wc_i\in{}R , \forall  i \in{} \{1,...,n\}}$ - аудитория, соответствующая окну i.


Введём множество Solutions, состоящее из функций булевых переменных, которые принимают значение 1, если за i-ей аттестацией бронируется j-е окно:
\begin{equation}
	S(i,j) = 
	\begin{cases}
		1 &\text{ the attestation $e_i$ is held in window $w_j$} \\
		0 &\text{ the attestation $e_i$ is not held in window $w_j$}.
	\end{cases}
\end{equation}


%\textbf{СЛЕДУЮЩАЯ ПОСТАВНОВКА ЯВЛЯЕТСЯ КЛЮЧЕВОЙ. По критериям качества где-то написано, но в нескольких местах, здесь бы собрать и конкретно уточнить, что использовалось. Ограничения вроде все идут из следующего пункта.}
% Вынесала метрики качества, ограничения - весь следующий пункт

Таким образом, необходимо найти значения функции ${S \in Solutions}$ для ${ \forall  i  \in \{1,..,k\}}$  и  ${ \forall j \in \{1,..,n\}}$ при условии соблюдения ряда ограничений (см. пункт~\ref{subsec:constraints}) и оптимизации ряда критериев качества: длительности сессии для каждого преподавателя/учебной группы, cуммарной длительности минимального отдыха между событиями по группам и суммарного количества рабочих дней преподавателей в период сессии (см. пункт~\ref{subsec:quality-func}). Множество пар <i,j>, для которых S(i,j) = 1, представляют собой расписание сессии - соответствие аттестации дню, времени и аудитории.

%\textbf{ПА: Где-то здесь был бы очень востребован пример, что есть что, т.к. выбранные обозначения очень начинают путаться. Кроме того, не совсем понятно, что выбрана за единицу измерения окна и аттестацию, как они сопрягаются. Маленький иллюстративный пример хорошо бы пошёл и в ПРЕЗЕНТАЦИЮ. Кстати, где она?}
% окно - кабинет, свободный в определённый день в определённый час
%Выше дано про окно - <...> для которых ${wd_i \in D}$ - календарный день, соответствующий окну i, ${wh_i \in H}$ - время, соответствующее окну i, ${wc_i\in{}R , \forall  i \in{} \{1,...,n\}}$ - аудитория, соответствующая окну i. 
% Выше дано про аттестацию - Аттестации, которые необходимо провести в течение сессии описываются учебной группой, дисциплиной и преподавателями, которые должны провести данную аттестацию. Так же для каждой аттестации необходимо указать её тип и тип аудитории, в которой она должна проводиться. 

Программно описанные в этом параграфе множестве реализованы в качестве классов, представленных в приложении~\ref{appendix-classes}. Далее подробно рассмотрим ограничения решаемой оптимизационной задачи.

\subsection{Ограничения}\label{subsec:constraints}
Задача составления расписания сессии имеет ряд физических ограничений, а также ограничений, обусловленных правилами проведения сессии. Соблюдение этих ограничений позволит составить корректное расписание сессии:

\textbf{ПА: Иногда не совсем понятны обозначения ограничений.}

Во-первых, в одной аудитории в одно время может проводиться максимум одна аттестация. То есть для любого из n окон справедливо, что среди всех k аттестаций ему можно выставить не более одной аттестации:
\begin{align}
	& \forall  j \in \{1,..,n\} \sum_{i=1}^kS(i,j) \leq 1.
\end{align}

%\textbf{ПА: Если верить нотации, введенной ранее, то запись всего лишь означает the attestation $e_i$ is held in window $w_j$, причем здесь комментарий, что в одной аудитории в одно время 1 аттестация? Если мы пробежимся по всем окнам и суммируем, то вроде просто наберем единичек.}
% Расширила комментарий над формулой. Должно стать понятнее

Каждая аттестация в период сессии должна проводиться единожды, так как в данном случае не рассматривается расписание дополнительной сессии:
\begin{align}
	& \forall  i \in \{1,..,k\} \sum_{j=1}^nS(i,j) = Ad_ea_i,
\end{align}
где $Ad_ea_i$ - длительность i-ей аттестации.
%\textbf{ЗДЕСЬ УЖЕ НЕ ЯСНО, ЧТО ТАКОЕ Ad_ea_i.} 

Преподаватель не должен отрабатывать в определённый день больше некоторого количества часов x:
\begin{align}
	& \forall b \in \{1,..,p\} : \sum_{\forall i \in \{1,..,k\}, et_{ia}=t_b}\sum_{\forall j \in \{1,..,n\}}\sum_{ \forall u \in d_u \in D, wd_j = d_u }S(i,j) \leq x.
\end{align}

Любая группа не может сдавать аттестации любого типа в день больше, чем максимальное число, обусловленное типом аттестации:
\begin{align}
	\begin{multlined}
		\forall b \in \{1,..,g\}, \forall j \in \{1,..,n\}, \forall m \in \{1,..,y\} :\\ \sum_{\forall i \in \{1,..,k\}, et_i = a_m,  eg_i=gr_b}\sum_{ \forall d \in D, wd_j = d }S(i,j) \leq ac_m * ad_m,
	\end{multlined}
\end{align}
где $ac_m * ad_m$ - общее число часов, разрешённое на проведение у одной учебной занятий m-ого типа аттестации.
%\textbf{ЗДЕСЬ БЫ РАСШИФРОВАТЬ, ЧТО ТАКОЕ $ac_m * ad_m$, ЧТОБЫ ЧИТАТЕЛЬ НЕ ЛОМАЛ ГОЛОВУ И НЕ СОМНЕВАЛСЯ В КОРРЕКТНОСТИ ЗАПИСИ ОГРАНИЧЕНИЙ. Везде делаем по аналогии и ставим в конце формул (предложений) ТОЧКИ. ВЕЗДЕ ДОЛЖНЫ БЫТЬ ЗНАКИ ПРЕПИНАНИЯ.} Done.

Любая группа перед любой своей аттестацией не должна иметь аттестаций в окно отдыха перед аттестацией этого типа:
\begin{align}
	\begin{multlined}
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\
		\max_{\forall j \in \{1,..,n\}, ed_j < ed_i}(ed_j) <ed_i-pb_{et_i}.
	\end{multlined}
\end{align}

Любая группа после любой своей аттестацией не должна иметь аттестаций в окно отдыха после аттестацией этого типа:
\begin{align}
	\begin{multlined}
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\
		\min{\forall j \in \{1,..,n\}, ed_j > ed_i}(ed_j) >ed_i-pa_{et_i}.
	\end{multlined}
\end{align}

%\textbf{ЗАПИСИ СТРЕМИТЬСЯ К S(i,j) = 0 НАВЕРНО ОБОЗНАЧАЮТ НЕ ТО, ЧТО ВВОДИЛОСЬ РАНЬШЕ the attestation $e_i$ is not held in window $w_j$} То же самое. Расширила комментарий над формулой.

Каждая аттестация должна проводиться в аудитории равной и или превосходящей по вместимости размеру группы. То есть для любого окна справедливо, что из факта, что размер группы превышает размер аудитории, следует, что нельзя проводить данное занятие в это окно:
\begin{align}
	& \forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : s_{eg_i} > rs_{wc_j} \rightarrow S(i,j) = 0.
\end{align}

Каждая аттестация не может проводиться в аудитории с оснащённостью меньшей ожидаемой:
\begin{align}
	& \forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : er_i < rt_{wc_j} \rightarrow S(i,j) = 0.
\end{align}

Чтобы составить расписание, комфортное для преподавательского состава, учтём некоторые ограничения связанные с предпочтениями преподавателей. Эти ограничения уже не столь критичны, как перечисленные выше, так как их нарушение не влечёт за собой нарушение правил или законов физики, но их наличие делает расписание более удобным для сотрудников.

Каждый преподаватель волен указать список календарных дней, в которые он готов принимать аттестации. Идеальное расписание предполагает, что любой преподаватель проводит все свои аттестации только в дни из этого списка:
\begin{align}
	\label{eq:T1}
	& \forall t \in T, \forall d \in D : d \notin Td_t \rightarrow S(i,j) = 0.
\end{align}

Также, преподаватель может указать удобные для него часы проведения аттестаций. Идеальное расписание учитывает это и располагает аттестации так, чтобы они затрагивали только выбранные часы каждого преподавателя:
\begin{align}
	\label{eq:T2}
	& \forall t \in T, \forall h \in H : h \notin Tt_h \rightarrow S(i,j) = 0.
\end{align}

Данная задача относится к классу NP-полных задач, а значит в худшем исходе придётся перебрать все возможные k аттестаций и n окон в качестве аргументов функции S(i,j), где выполняются все описанные выше ограничения. Обобщим их для функции S:

\begin{equation}
	\label{eq:S}
	S(i,j) = 
	\begin{cases}
		\forall  j \in \{1,..,n\} \sum_{i=1}^kS(i,j) = 1;\\
		\forall  i \in \{1,..,k\} \sum_{j=1}^nS(i,j) = Ad_ea_i;\\
		\forall b \in \{1,..,p\} : \\ \sum_{\forall i \in \{1,..,k\}, et_{ia}=t_b}\sum_{\forall j \in \{1,..,n\}}\sum_{ \forall u \in d_u \in D, wd_j = d_u }S(i,j) \leq x;\\
		\forall b \in \{1,..,g\}, \forall j \in \{1,..,n\}, \forall m \in \{1,..,y\} :
		\\ \sum_{\forall i \in \{1,..,k\}, et_i = a_m,  eg_i=gr_b}\sum_{ \forall d \in D, wd_j = d }S(i,j) \leq ac_m * ad_m;\\
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b: \\ \max\limits_{\forall j \in \{1,..,n\}, ed_j < ed_i}(ed_j) <ed_i-pb_{et_i};\\
		\forall b \in \{1,..,g\}, \forall i \in \{1,..,k\} eg_i=gr_b:\\ \min\limits_{\forall j \in \{1,..,n\}, ed_j > ed_i}(ed_j) >ed_i-pa_{et_i};\\
		\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : s_{eg_i} > rs_{wc_j} \rightarrow S(i,j) = 0;\\
		\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\} : er_i < rt_{wc_j} \rightarrow S(i,j) = 0\\
	\end{cases}
\end{equation}

Оптимальным расписанием будет такое, где минимальное количество пожеланий преподавателей игнорируется. Таким образом, сведём задачу к поиску такого расписания S, на котором выполняется следующий минимум:

\begin{align}
	\label{eq:T}
	& \min_{\forall S \in Solutions}(\sum_{\forall i \in \{1,...,k\}, \forall j \in \{1,..,n\}, wd_j \notin Td_{et_i}, wh_j \notin Th_{et_i}}(S(i,j)*pr_{et_i})).
\end{align}

Видно, что идеальными расписаниями будут те, где учитываются пожелания всех преподавателей, так как в этом случае точно достигается наименьшее значение минимума формулы \eqref{eq:T} = 0. 

Для решения данной задачи рассмотрим алгоритмы динамического и линейного программирования, алгоритм на графах, эволюционный алгоритм и метод численной оптимизации.

\section{Режимы алгоритмов составления расписания} \label{ch2:sec2} 

Алгоритмы составления расписания можно использовать в двух режимах: инкрементальном и пакетном (batch-режим). В данном разделе рассмотрим, что из себя представляет каждый из этих режимов и почему пакетный режим больше подходит для решения задачи составления расписания сессии.

\subsection{Инкрементальный режим}

Инкрементальным режимом назовём выполнение алгоритма многократно при появлении новых данных. В контексте данной задачи это означает, что каждый раз, когда новый преподаватель будет добавлять информацию о своих предпочтениях, алгоритм будет просчитывать возможные варианты расписания с учётом:
\begin{itemize}
	\item уже имеющихся данных, которые имеют приоритет, перед новыми;
	\item внесённых преподавателем изменений.
\end{itemize}

Так, при каждом новом пересчёте уже составленные расписания преподавателей считаются утверждёнными, что даёт возможность не считать их заново, тем самым ускорив работу алгоритма.

Из преимуществ данного подхода можно выделить возможность преподавателя, не дожидаясь других, увидеть своё расписание. Также, с точки зрения организации, плюсом можно считать стимул преподавателей как можно раньше заполнить форму сбора информации, чтобы иметь приоритет перед другими. Таким образом появляется возможность раньше закончить процесс составление расписания. 

Недостатки данного режима более существенны на практике, чем его преимущества, так как основным недостатком является закрепление наиболее удобного расписания за теми, кто заполнил форму сбора раньше остальных, что может повлечь коллизии. Можно рассмотреть случай, когда первый преподаватель, заполнивший форму сбора, выбирает большое окно для проведения экзаменов и алгоритм бронирует за ним несколько определённых случайных дат, а остальные оставляет свободными. Тогда второй преподаватель, уезжающий на конференцию в свободные даты и готовый провести экзамены в даты, занятые первым, уже не сможет это сделать, потому что у первого преподавателя приоритет, и его уже нельзя подвинуть на сводные даты.

\subsection{Пакетный режим}

Пакетным режимом в данном случае будет единоразовая обработка всех полученных сведений. Для этого необходимо определить дедлайн для сбора пожеланий преподаватель, при наступлении которого составить предварительное расписание для всех за один вызов алгоритма. 

Преимуществом такого подхода является возможность установить приоритеты преподавателей и групп, на основе которых можно решать коллизии в случае невозможности нахождения идеального решения, учитывающего пожелания каждого. 

Недостатком такого подхода можно назвать невозможность до дедлайна получить расписание, но в реальности это не будет глобальным минусом, потому что составленное таким образом предварительное расписание, всё равно, в последствии может быть скорректировано вручную. 

Таким образом, из двух рассмотренных режимов для решения задачи составления расписания больше подходит именно пакетный, потому что его преимущества более значимы, а единственный недостаток не играет роли на практике, в отличие от описанных недостатков инкрементального режима.

\section{Обзор алгоритмов составления расписания сессии} \label{ch2:sec3} 
\subsection{Обход графа в глубину для поиска идеальных решений}

Задача составления расписания сессии является NP-полной, как, например, задача обхода графа, для которой существует множество классических алгоритмов, решающих её. Алгоритм обхода графа в глубину, описанный в книге <<The Art of Computer Programming>> ~\cite{dfs}, является одним из них. Далее Но чтобы применить этот алгоритм для составления расписания, необходимо свести эту задачу к задаче построения графа, у которого в качестве вершин выступают элементы расписания - аттестации и временные окна для их проведения. Наличие ребра обуславливается выполнением двух следующих условий:
\begin{itemize}
	\item ребро из вершины с аттестацией i из отсортированного списка аттестаций E, может быть соединено только с аттестацией i+1 из E;
	\item ребро из вершины <i,j> с аттестацией i и окном j в вершину <i+1, q> может существовать, если выполняются условия формул \eqref{eq:S}, \eqref{eq:T1} и \eqref{eq:T2} для S(i+1, q) при n=i+1.
\end{itemize}

Тогда решением будет являться связный граф состоящий из k вершин - пар аттестаций и временных окон, отведённых для этих аттестаций.

Основная идея обхода в глубину – когда возможные пути по ребрам, выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим веткам. Сложность классического обхода в глубину с матричным заданием графа равна ${O(m^2)}$, где {$m=n*k$} - количество вершин. Но так как известно, что доступность рёбер для каждой из вершин с аттестацией i ограничена n вершинами с аттестацией i+1, сложность снизится до ${O(n^2 * k)}$. Но так как для проверки остальных условий необходимо проверять i предыдущих вершин графа, сложность останется ${O(n^2 * k*\log(k))}$.

В процессе решения значениями функции S(i,j) будет заполняться булева матрица. Важно помнить, что значение 1 в ячейке может быть проставлено, только при соблюдении ограничений системы \eqref{eq:S} , и стоит заметить, что выполнение ограничения, что в одной аудитории в одно время может проводиться только одна аттестация, влечёт за собой наличие в одном столбце матрицы не более одного значения 1, из-за чего матрицу можно заменить на целочисленный массив, где индексы соответствуют индексу возможного окна, а значения - индексу события, которое будет там проведено.

Будем считать, что идеальное решение найдено, если в каждой строке матрицы есть значение 1 или каждое число от 0 до k встречается в массиве решения, что означает, что каждую аттестацию можно сопоставить какому-то окну ${w_j}$ c учётом перечисленных выше ограничений. Такое решение добавляется в список всех идеальных решений. Далее представлен псевдокод процедуры FindSolutions~\ref{alg:algoFindSol}. , которая реализует алгоритм обхода графа в глубину. Заметим, что в списке доступных окон W все элементы отсортированы по дням, кабинетам и часам, чтобы легко можно было оценивать занятость одного кабинета несколько часов подряд.

\begin{algorithm} 
	\SetKwFunction{algoFindSol}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSol}{
		\KwInput{$\cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[Solutions]$} 
		{$Solutions \leftarrow \{\}, $}
		{$S \leftarrow [], $}
		{$i \leftarrow 0$}\\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$ Solutions$}
				} \Else {
					{$i \leftarrow i-1$}\\
				}
			} \Else {
				{$duration = ed_i $}\\
				\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
					{$S[b] \leftarrow i$}\\
				}
				{$i \leftarrow i+1$}\\
			}
			\If{$i = k$ }{
				{$Solutions \leftarrow Solutions \bigcup S$}\\
				{$i \leftarrow i-1$}\\
			} 
		}
		\Return {$ Solutions$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} для составления расписания}\label{alg:algoFindSol}
\end{algorithm} 

В процедуре FindNextStartTime~\ref{alg:algoFindNextPr} проводится проверка условий из формулы \eqref{eq:S}, чтобы подобрать следующее подходящее ребро, исходящее из указанной вершины. В случае, если для вершины не существует исходящего ребра, которое удовлетворяет всем условиям, данная процедура вернёт значение -1, в противном случае вернёт следующее ребро. В данной функции также происходит проверка условий из формул \eqref{eq:T1} и \eqref{eq:T2}, чтобы обеспечить поиск идеального решения, удовлетворяющего пожеланиям всех преподавателей. 

%\textbf{ПА: Здесь нужно новые обозначения расшифровать. Далее по аналогии ВЕЗДЕ ГДЕ ЕСТЬ АЛГОРИТМЫ  также привести минимум 2 абзаца текста, раскрывающего смысл алгоритма, новых обозначений.}

\begin{algorithm} 
	\SetKwFunction{algoFindNext}{} 
	\SetKwProg{myalg}{Function}{ FindNextStartTime}{}
	\nonl\myalg{\algoFindNext}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$t$} 
		\If{$ time < 0$ } {
			\Return -1 \\
		}	
		\For{$i \in \{time,...,k\} $}{
			{$w \leftarrow W[i]$}\\
			\If {$S[i] = -1 
				\land rt_{w} = er_{event}  
				\land i + ad_{event} < n 
				\land s_{eg_{event}} \leq er_{w}
				\land er_{w} = er_{W[i+ad_{event}]}
				\land ed_{w} = ed_{W[i+ad_{event}]}
				\land wd \in Td_{event}
				\land wt \in Tt_{event}
				\land wt+ed_{w} \in Tt_{event}$}
			{
				{$teacherTime \leftarrow 0, countPerDay \leftarrow 0, 	j \leftarrow 0 $} \\
				\While{$i < k$}{
					\If {$S[j] = -1 $}{
						{$j \leftarrow j+1$}\\
						{$continue$}\\
					}
					\If {$w = S[j] 	\land wt \in et_{solution[j]}$}{
						{$break$}\\
					}
					\If {$et_{S[j]} = et_{event}$}{
						{$teacherTime=teacherTime+1$}\\
						\If {$teacherTime > maxTimePerDay - ed_{event}$}{
							{$break$}\\
						}
					}
					\If {$eg_{S[j]} = eg_{event}$}{
						\If {$(ea_{S[j]=ea_{event}}) \land (wd = ed_{S[j]})$}{
							{$ countPerDay \leftarrow countPerDay+1 $} \\
							\If {$(ac_{et_{event}} < countPerDay) \lor (wt-pb_{ea_{event}}\leqwd_{S[j]}\land wt+pa_{ea_{event}}>=wd_{S[j]})$}{
								{$break$}\\
							}
						}
						{$k \leftarrow k+1$}
					}	
				}
				\If{$j = n$}{
					\Return {$i$} \\
				}
			}
		}
		\Return -1
	}
	\caption{Проверка условий формул \eqref{eq:S}, \eqref{eq:T1} и \eqref{eq:T2}} \label{alg:algoFindNext}
\end{algorithm} 



\FloatBarrier
\subsection{Алгоритм обхода графа в глубину с учётом приоритетов преподавателей}

На практике возникают ситуации, когда недостаток аудиторий и накладки в личных расписаниях преподавателей не позволяют найти такое расписание, которое удовлетворит всем пожеланиям. По этой причине приходится учитывать приоритеты ограничений и минимизировать потери по формуле \eqref{eq:T}. 

Существует ряд ограничений, поступиться с которыми нельзя. В их число входят правила проведения аттестаций и физические условия, связанные с проведением экзаменов в аудиториях, опписанные в формуле \eqref{eq:S}. Но есть и менее жёсткие факторы - это пожелания преподавателей к датам и времени экзаменов. 

Каждый преподаватель указывает дни и время, когда ему было бы удобно присутствовать на аттестации. В некоторых случаях удобство эквивалентно тому, что в остальные дни преподаватель в принципе не может принимать экзамены. Приоритет таких ограничений должен быть выше, чем у случаев, когда преподавателю просто комфортнее было бы присутствовать на экзаменах в определённые дни.

Для этого было введено множество приоритетов Pr, где больший приоритет соответствует большему влиянию учёта пожеланий преподавателя на потери функции \eqref{eq:T}. Система приоритетов в случае появления коллизий при составлении расписания позволит в первую очередь пытаться нарушить только пожелания с наименьшим приоритетом и только, если это необходимо, с более высокими.

Модернизируем алгоритм поиска «идеального» решения:

Для этого нужно хранить массив ignoreWishes, в котором будут фиксироваться те аттестации, для которых приходится искать решения без учёта предпочтений преподавателей.

Также, в алгоритме~\ref{alg:algoFindSolPr} на строке~\ref{step:sortE} необходимо отсортировать массив аттестаций по приоритетам преподавателей, чтобы искать решения без учёта высокоприоритетных преподавателей лишь в последнюю очередь. 

Метод поиска решений FindSolutions~\ref{alg:algoFindSolPr} теперь содержит условный оператор, который в случае определения того, что идеального решения найти не удаётся, переходит в режим игнорирования пожеланий преподавателя для конкретного события. Для этого в массиве ignoreWishes выставляется true по индексу, соответствующему этому событию.

\begin{algorithm} 
	\SetKwFunction{algoFindSolPr}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSolPr}{
		\KwInput{$\cont[P], \cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[S]$} 
		{$ignoreWishes \leftarrow [], $}
		{$S \leftarrow [], $}
		{$i \leftarrow 0$}\\
		{$Sort(E)$\label{step:sortE}} \\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If {$ ignoreWishes[i] = False \land nextTime = -1$ }{
				{$ignoreWishes[i] = True$} \\
				{$nextTime = FindNextStartTime(i,0)$}\\
			}
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$null$}
				} \Else {
					{$ignoreWishes[i] = False$}\\
					{$i \leftarrow i-1$}\\
				}
			} \Else {
				{$duration = ed_i $}\\
				\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
					{$S[b] \leftarrow i$}\\
				}
				{$i \leftarrow i+1$}\\
			}
		}
		\Return {$ S$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} для составления расписания c учётом приоритетов преподавателей}\label{alg:algoFindSolPr}
\end{algorithm} 

Метод поиска следующего подходящего времени и аудитории теперь может работать в двух режимах. В режими игнорирования рассматриваются только те окна, которые хотя бы в какой-то мере не удовлетворяют пожеланиям преподавателя. Для этого в алгоритме~\ref{alg:algoFindNextPr} в строке~\ref{step:ignor} используется логический оператор XOR между результатом проверки соблюдения пожеланий преподавателя и значением в массиве игнорирования.

\begin{algorithm} 
	\SetKwFunction{algoFindNextPr}{} 
	\SetKwProg{myalg}{Function}{ FindNextStartTime}{}
	\nonl\myalg{\algoFindNextPr}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]|, ignoreWishes $} 
		\KwOutput{$t$} 
		\If{$ time < 0$ } {
			\Return -1 \\
		}	
		\For{$i \in \{time,...,k\} $}{
			{$w \leftarrow W[i]$}\\
			{$teacherWish \leftarrow (wd \in Td_{event}
				\land wt \in Tt_{event}
				\land wt+ed_{w} \in Tt_{event}) \nsim ignoreWishes[i]$ \label{step:ignor}}\\
			\If {$S[i] = -1 
				\land rt_{w} = er_{event}  
				\land i + ad_{event} < n 
				\land s_{eg_{event}} \leq er_{w}
				\land er_{w} = er_{W[i+ad_{event}]}
				\land ed_{w} = ed_{W[i+ad_{event}]}
				\land teacherWish$}
			{
				...\\
			}
			\If{$j = n$}{
				\Return {$i$} \\
			}
		}
		\Return -1
	}
	\caption{Проверка условий формулы \eqref{eq:S} с учётом режима игнорирования}\label{alg:algoFindNextPr}
\end{algorithm} 
Асимптотическая сложность этой интерпретации алгоритма тоже равна ${O(n^2 * k)}$, но требует дополнительную память на хранение бинарного массива ignoreWishes. 
\FloatBarrier

\subsection{Генетический алгоритм}
По данным книги <<Evolutionary Multiobjective Optimization. Theoretical Advances and Applications>> ~\cite{gen}, генетический алгоритм имитирует естественный отбор и состоит из нескольких этапов:
\begin{itemize}
	\item cоздание популяции;
	\item pазмножение путём обмена генами у двух особей;
	\item мутации путём проведения определённых изменений генов некоторых особей;
	\item расчёт метрики приспособленности для особей и отбор лучших для перехода в новое поколение.
\end{itemize}

Определим основные понятия генетического алгоритма для простого случая составления расписания. Ген будет представлять собой объект с полями: Группа, Преподаватель, Предмет, Тип аттестации, Дата, Время, Аудитория. Популяция - все возможные комбинации расположения аттестаций по аудиториям во времени. Особь - некоторый набор генов (пример расписания). Такая задача сводится к нахождению наилучшей особи - расписания.

Фитнес-функция для этого алгоритма, в которой задаётся способ расчёта метрики качества расписания, должна учитывать ограничения \eqref{eq:S}, чтобы с каждым новым поколениям расписания имели всё меньше и меньше накладок.

Из  преимуществ генетического алгоритма можно выделить:
\begin{itemize}
	\item Адаптивность времени выполнения;
	\item Возможность ограничить количество поколений алгоритма, по истечении которых алгоритм оставит наиболее подходящее расписание;
	\item Адаптивность качества;
	\item Если задать условием остановки алгоритма - достижение некоторого счёта в фитнес-функции, можно завершить работу с приемлемыми потерями, полученными, например, от пренебрежения пожеланиями преподавателями.
\end{itemize}

Недостатками генетического алгоритма для задачи составления расписания будут:
\begin{itemize}
	\item Массивные входные данные, так как для формирования популяции необходимо брать декартово произведение нескольких датасетов, а после манипулировать большой начальной популяцией;
	\item Нелинейная зависимость качества от длительности выполнения, так как часто в эволюционных алгоритмах последующее поколение бывает менее приспособлено, чем предыдущее, а значит, заранее предугадать количество итераций при заданном минимальном пороге качества нельзя;
	\item Сложность подбора параметров фитнес-функции;
	\item Длительная отладка.
\end{itemize}

\subsection{Жадный алгоритм}
В данном пункте рассматриваю концепцию жадного алгоритма из книги <<Совершенный алгоритм. Жадные алгоритмы и динамическое программирование>>~\cite{zhad}: жадный алгоритм - алгоритм, который на каждом шаге выбирает локально оптимальное решение, ожидая, что итоговое решение тоже будет оптимальным. В какой-то мере жадным алгоритмом пользуются диспетчеры при составлении расписания сессии: сначала выставляются даты для аттестаций проводимых высокоприоритетными преподавателями-совместителями, а далее в свободные окна расставляются менее приоритетные.

Но программная реализация жадного алгоритма при составлении расписания слишком часто не будет сходиться к решению, которое удовлетворяет всем ограничениям. Во многих задачах допустимо искать не глобальный оптимум решения, чтобы уменьшить время выполнения, но при составлении расписания сессии нельзя пренебрегать рябом ограничений, а значит если на какой-то итерации алгоритма некоторую аттестацию остаётся расположить в занятой аудитории, применение такой оптимизации совершенно теряет смысл. Можно повторять жадный поиск решения несколько, если сразу не удаётся найти подходящее расписание, но так процесс подбора решения потеряет свою "жадность" и выродится к полному перебору.

\section{Методы оптимизации поиска лучших решений} \label{ch2:sec4} 
\subsection{Метрики оценки качества расписания}\label{subsec:quality-func}
Для оценки предложенных расписаний подсчитаем несколько метрик:

Длительность сессии для каждого преподавателя с учётом его приоритета:
\begin{align}
	& {DurationT} =  \sum\limits_{\forall  t \in T}(pr_t* (\max\limits_{i \in \{0,...,n\}, et_{S[i]} = t}(wd_{i}) 
	- \min\limits_{i \in \{0,...,n\}, et_{S[i]} = t}(wd_{i}) )) 
\end{align}

Считаем, что расписание преподавателя должно быть максимально компактным по датам, а значит разницу между первым и последним днём проведения экзаменов нужно минимизировать.

Суммарная длительность минимального отдыха между экзаменами по группам:
\begin{align}
	& {Pause} =  \sum\limits_{\forall  gr \in Gr}(\min\limits_{i,j \in \{0,...,n\}, eg_{S[i]} = gr, wd_i \neq wd_j, i>j}(wd_i - wd_j))
\end{align}
Считаем, что студентам желательно не иметь маленьких перерывов между экзаменами, поэтому стремимся максимизировать Pause для расписания.

Суммарная длительность сессии по группам:
\begin{align}
	& {DurationG} =  \sum\limits_{\forall  gr \in Gr}\max\limits_{i \in \{0,...,n\}, eg_{S[i]} = gr}(wd_i)
\end{align}

Чем раньше закончится сессия, тем раньше у иногородних студентов появится возможность уехать домой, а значит порядковый номер последнего дня сессии для группы нужно пытаться минимизировать.

Суммарное кол-во рабочих дней для преподавателей с учётом их приоритетов:
\begin{align}
	& Work_t = \{wd_i, \forall i \ in {1,...,n}, et_{S[i]} = t\};\\
	& {WDays} =  \sum\limits_{\forall  t \in T}(pr_t * \|Work_t\|) 
\end{align}

Считаем, что преподавателю удобно иметь максимальное количество дней, свободных от проведения экзаменов, а значит метрику WDays стараемся минимизировать. На практике это означает, что лучше провести несколько зачётов в один день, чем заставлять человека несколько раз в неделю приезжать в университет.

Все эти метрики имеют разные шкалы, какие-то мы пытаемся максимизировать, какие-то минимизировать, одни измеряются несколькими неделями, а другие несколькими днями. Поэтому каждую метрику для всех рассматриваемых решений необходимо нормализовать. Это приведёт данные метрики к единой шкале и улучшит их интерпретируемость.

Ко всем метрикам качества для выбранных для сравнения расписаний применим минимаксную нормализацию \cite{minimax}, которая рассчитывается по формуле:
\begin{align}
	& X' =  \frac{X-X_{min}}{X_{max}-X_{min}}
\end{align}

Далее сделаем так, чтобы большему значению каждой метрики соответствовало более предпочтительное расписание. Для этого те метрики, для которых лучшее решение имеет меньшее значение - вычтем из 1. Тем самым соотношение всех значений метрики среди расписаний останется таким же, но качество метрики будет расти с качеством решения. 

\subsection{Метод ветвей и границ}
Метод ветвей и границ, описанный в <<An automatic method of solving discrete programming problems>>~\cite{branch}, принадлежит к группе алгоритмов целочисленного линейного программирования и применяется для оптимизации задач полного перебора. Он как нельзя кстати придётся для модернизации алгоритма полного обхода графа в глубину.
Суть этого метода состоит в том, чтобы в процессе обхода графа, отбрасывать заведомо менее оптимальные решения, чем у же найденные.

Такой подход потребует выделить память под хранение метрик качества. В памяти необходимо держать качество текущего рассчитываемого расписания и предыдущего лучшего расписания.
В качестве метрики качества возьмём разброс между первым и последним днём проведения сессии для каждого преподавателя. Чем он меньше, тем лучше считается расписание. Естественно, можно выбрать и другие критерии качества расписания, но алгоритм при этом поменяется незначительно.
Выбор такой метрики вынуждает хранить массив с количеством дней разброса для каждого преподавателя, поэтому выделим память под массивы metrics[] и bestMetrics[] размером p (число преподавателей).

Модернизируем функцию поиска решений методом обхода графа в глубину, 
добавив в качестве условия перехода к следующей аттестации проверку на то, является ли расписание на данном этапе, худшим, чем предыдущее полностью составленное расписание. Эта проверка добавляется в строке~\ref{step:isitw} алгоритма~\ref{alg:algoFindSolV}.

\begin{algorithm} 
	\SetKwFunction{algoFindSolV}{} 
	\SetKwProg{myalg}{Algorithm }{ FindSolutions}{}
	\nonl\myalg{\algoFindSolV}{
		\KwInput{$\cont[E], \cont[W], k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[Solutions]$} 
		{$metrics \leftarrow [], $}
		{$bestMetrics \leftarrow [], $}
		{$Solutions \leftarrow \{\}, $}
		{$S \leftarrow [], $}
		{$i \leftarrow 0$}\\
		\While{$i < k$}{
			{$time = NextTime(i)$} \\
			\For{$\forall u \in {0,...,k }$}{
				\If{$ S[u] = i $ } {
					{$S[u] \leftarrow -1$} \\
				}	
			}
			{$nextTime = FindNextStartTime(i,time)$}\\
			\If{$nextTime = -1$ }{
				\If{$i = 0$ }{
					\Return {$ Solutions$}
				} \Else {
					{$i \leftarrow i-1$}\\
				}
			} \Else {
				{$duration = ed_i $}\\
				\For{$\forall b \in \{nextTime,...,nextTime + duration\} $} {
					{$S[b] \leftarrow i$}\\
				}
				{$i \leftarrow i+1$}\\
				\If {$i = 0 \lor \urcorner isItWorse(i)$ \label{step:isitw}} {
					{$i \leftarrow i+1$}\\
				} \Else {
					\Return {$ Solutions $}\\
				}
			}
			\If{$i = k$ }{
				{$Solutions \leftarrow Solutions \bigcup S$}\\
				{$bestMetrics \leftarrow metrics$}\\
				{$i \leftarrow i-1$}\\
			} 
		}
		\Return {$ Solutions$}\\
	}
	\caption{Псевдокод алгоритма \texttt{DFS} c использованием метода ветвей и границ} \label{alg:algoFindSolV}
\end{algorithm} 
\FloatBarrier
Функция isItWorse~\ref{alg:algoW} пересчитывает для рассматриваемого преподавателя длительность его сессии и проверяет, не является ли оно худшим, чем у того же преподавателя в предыдущем полном расписании. Для этого в массиве текущего решения находится максимальный и минимальный день, для рассматриваемого преподавателя и возвращается их разница.

\begin{algorithm} 
	\SetKwFunction{algoW}{} 
	\SetKwProg{myalg}{Function}{ isItWorse}{}
	\nonl\myalg{\algoW}{
		\KwInput{$event, time, \cont[E], \cont[W], \cont[S], k = |\cont[E]|, n = |\cont[W]|, ignoreWishes $} 
		\KwOutput{$t$} 
		{$max,min \leftarrow wd_{n-1}, i \leftarrow event - 1$}\\
		\While{$ i >= 0 \land et_{i} = et_{event}$ } {
			{$ j \leftarrow \min_{j \in {0,k-1}, S[j]=i}(j)  $}\\
			\If{$ wd_j > max$}{
				{$max = wd_j$}\\
			} \ElseIf{$wd_j < min$}{
				{$min = wd_j$}
			}
			{$ i \leftarrow i - 1$}\\
		}
		{$ metrics[event] \leftarrow max-min$}\\
		\Return {$ bestMetrics[0] \neq -1 \land bestMetrics[et_{event}] < metrics[et_{event}]$}
	}
	\caption{Функция сравнения метрики качества для преподавателя с предыдущим лучшим решением}	
	\label{alg:algoW}
\end{algorithm} 
\FloatBarrier

\subsection{Алгоритм имитации отжига}
Для выбора лучшего из расписаний и расчёта всех метрик необходимо будет дополнительно обойти x расписаний, состоящих из n возможных временных окон. А потом просуммировать их по p преподавателям и g учебным группам. 
Если входные данные были такими, что было найдено 5-10 возможных расписаний, то не составит труда просчитать их все, так как относительно n - числа временных окон, оно вносит минимальный вклад в сложность вычислений.

Но рассмотрим случай, когда методом полного перебора было найдено большое количество возможных расписаний, и число x достаточно велико и даже сравнимо с n. В такой ситуации было бы полезно находить более оптимальные решения без расчёта метрик для каждого расписания, жертвуя некоторой погрешностью.

Для этого можно применить оптимизационный алгоритм имитации отжига, описанный в статье <<On simulated annealing phase transitions in phylogeny reconstruction>> ~\cite{sim}. Он основан на имитации физического процесса отжига металлов - при постепенно понижающейся температуре переход атома из одной ячейки кристаллической решётки в другую происходит с некоторой вероятностью, которая понижается с понижением температуры.

При помощи моделирования этого процесса ищется такая точка или множество точек, на котором достигается минимум некоторой функции F(S). Для задачи выбора лучшего расписания функция F(S) - функция, вычисляющая качество расписания, например, по метрике DurationG, где S - некоторое из полученных расписаний:
\begin{align}
	& {F(S)} =  \sum\limits_{\forall  gr \in Gr}\max\limits_{i \in \{0,...,x\}, eg_{S[i]} = gr}(wd_i)
\end{align}

Решение ищется последовательным вычислением точек {$S_0,...,S_f$ } из множества Solutions(для задачи выбора оптимального расписания - возможные варианты расписаний), где f - количество итераций понижения температуры. Каждая последующая точка претендует на то, чтобы лучше предыдущих приближать решение. В качестве исходных данных возьмём точку {$S_0$}. На каждом шаге алгоритм вычисляет новую точку и понижает значение счётчика - температуры {$Q_i$ }, и когда он достигает нуля, алгоритм останавливается в этой точке.

Температурой для данной задачи возьмём некоторую константу, достаточно большую, чтобы хватило итераций для нахождения примерного оптимума, но при этом меньшую, чем x. Пусть это будет константа {$Q_0 = \frac {n}{10}$}.

К точке {$x_i$} на каждом шаге применяется оператор A, который случайным образом модифицирует её, в результате чего получается новая точка {$x^*$}. Он возвращает следующее расписание для расчёта метрики качества на следующей итерации.

\begin{align}
	& A(S_i)= S_{Y(0, x-i)}\text{, Y - random number on a segment [0,x-i]}
\end{align}

Но перейдёт ли  {$S^*$} в  {$S_{i+1}$} произойдёт с вероятностью, которая вычисляется в соответствии с распределением Гиббса:
\begin{align}
	P(x^*\to{S_{i+1}}\mid{S_i})=
	\begin{cases}
		1, & F({S^*})-F({S_i})<0 \\
		\exp\left(-\dfrac{F(S^*)-F(S_i)}{Q_i}\right), & {F(S^*)-F(S_i)\geqslant 0}
	\end{cases}
\end{align}

В псевдокоде~\ref{alg:algoSA} представлено создание цикла понижения температуры, который возвращает расписание, которое будет выбрано, когда температура станет нулевой. 

\begin{algorithm} 
	\SetKwFunction{algoSA}{} 
	\SetKwProg{myalg}{Algorithm }{ SimulatedAnnealing}{}
	\nonl\myalg{\algoSA}{
		\KwInput{$\cont[Solutions], \cont[E], \cont[W], x = |\cont[Solutions]|, k = |\cont[E]|, n = |\cont[W]| $} 
		\KwOutput{$\cont[S]$} 
		{$i \leftarrow 0$}\\
		{$metrics[i] = F(Solutions[i])$}\\
		
		\For{$q \in {n/10,...,0}$}{
			{$next = A(Solutions[i])$}\\
			{$metrics[next] = F(Solutions[next])$}\\
			{$pr = P(S_{next})\mid{S_i})$}\\
			\If{$ Y(0,1 < p) $ } {
				{$i \leftarrow next$} \\
			}	
		}
		\Return {$ Solutions[i]$}\\
	}
	\caption{Псевдокод алгоритма имитации отжига для определения оптимального расписания из предложенных}\label{alg:algoSA}
\end{algorithm} 

Из преимуществ этого метода оптимизации можно выделить его скорость, потому что расчёт метрик качества расписания осуществляется только для установленного числа решений. Но при этом это снижает точность выбора наиболее удачного расписания, так как присутствует фактор случайности при выборе следующего решения на каждом шаге алгоритма.
\FloatBarrier
\section{Выводы} \label{ch2:conclusion}

Система составления расписания сессии СПбПу реализует алгоритм обхода в глубину с учётом приоритетов преподавателей, одним из входных параметров которого будет максимальное количество рассчитанных расписаний. Этот параметр необходим для ускорения работы алгоритма, если не стоит задачи выбирать самое лучшее из всех возможных расписаний. Реализация этого алгоритма представлена в приложении~\ref{appendix-source}.

Если выбрана метрика определения наиболее оптимального расписания, можно применить метод ветвей и границ, чтобы ещё ускорить вычисления и вернуть меньшее количество наиболее качественных расписаний сессии. Метод имитации отжига плохо применим к оптимизации выбора самого удачного расписания на практике, так как он нацелен на относительно большое число входных вариантов расписания, что во-первых редкость, потому что зачастую предпочтения преподавателей и загруженность помещений не даёт большой выбор расписаний, а во-вторых требует длительного времени на расчёт большого числа расписаний, среди которых будет выбираться лучшее.
